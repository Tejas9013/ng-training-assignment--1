# Angular Services Implementation

## 1. Task Service (src/app/services/task.service.ts)

```typescript
import { Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { environment } from '@environments/environment';
import { 
  Task, 
  TaskResponse, 
  TasksResponse, 
  TaskFilter,
  TaskStats
} from '@app/interfaces/task.interface';
import { TaskModel } from '@app/models/task.model';

@Injectable({
  providedIn: 'root'
})
export class TaskService {
  private apiUrl = environment.apiUrl;

  constructor(private http: HttpClient) {}

  /**
   * Get all tasks with optional filtering, pagination, and sorting
   */
  getTasks(filter: TaskFilter = {}): Observable<TasksResponse> {
    let params = new HttpParams();
    
    if (filter.status) {
      params = params.set('status', filter.status);
    }
    
    if (filter.priority) {
      params = params.set('priority', filter.priority);
    }
    
    if (filter.search) {
      params = params.set('search', filter.search);
    }
    
    if (filter.page) {
      params = params.set('page', filter.page.toString());
    }
    
    if (filter.limit) {
      params = params.set('limit', filter.limit.toString());
    }
    
    if (filter.sortBy) {
      params = params.set('sortBy', filter.sortBy);
    }

    return this.http.get<TasksResponse>(`${this.apiUrl}/tasks`, { params })
      .pipe(
        map(response => {
          response.data.tasks = response.data.tasks.map(task => 
            TaskModel.fromJSON(task)
          );
          return response;
        }),
        catchError(error => this.handleError(error))
      );
  }

  /**
   * Get a single task by ID
   */
  getTaskById(id: string): Observable<TaskModel> {
    return this.http.get<TaskResponse>(`${this.apiUrl}/tasks/${id}`)
      .pipe(
        map(response => TaskModel.fromJSON(response.data)),
        catchError(error => this.handleError(error))
      );
  }

  /**
   * Create a new task
   */
  createTask(task: Task): Observable<TaskModel> {
    return this.http.post<TaskResponse>(`${this.apiUrl}/task`, task)
      .pipe(
        map(response => TaskModel.fromJSON(response.data)),
        catchError(error => this.handleError(error))
      );
  }

  /**
   * Update an existing task
   */
  updateTask(id: string, task: Task): Observable<TaskModel> {
    return this.http.put<TaskResponse>(`${this.apiUrl}/task/${id}`, task)
      .pipe(
        map(response => TaskModel.fromJSON(response.data)),
        catchError(error => this.handleError(error))
      );
  }

  /**
   * Delete a task
   */
  deleteTask(id: string): Observable<TaskModel> {
    return this.http.delete<TaskResponse>(`${this.apiUrl}/task/${id}`)
      .pipe(
        map(response => TaskModel.fromJSON(response.data)),
        catchError(error => this.handleError(error))
      );
  }

  /**
   * Get task statistics
   */
  getTaskStats(): Observable<TaskStats> {
    return this.http.get<{ success: boolean, data: TaskStats }>(`${this.apiUrl}/tasks/stats`)
      .pipe(
        map(response => response.data),
        catchError(error => this.handleError(error))
      );
  }

  /**
   * Handle API errors
   */
  private handleError(error: any): Observable<never> {
    let errorMessage = 'An error occurred';
    
    if (error.error instanceof ErrorEvent) {
      // Client-side error
      errorMessage = `Error: ${error.error.message}`;
    } else {
      // Server-side error
      errorMessage = error.error?.message || 
                    `Error Code: ${error.status}, Message: ${error.message}`;
    }
    
    console.error(errorMessage);
    return throwError(() => new Error(errorMessage));
  }
}
```

## 2. Error Handling Service (src/app/services/error.service.ts)

```typescript
import { Injectable } from '@angular/core';
import { Subject } from 'rxjs';

export interface ErrorEvent {
  message: string;
  title?: string;
  type: 'error' | 'warning' | 'info' | 'success';
  autoClose?: boolean;
  duration?: number;
}

@Injectable({
  providedIn: 'root'
})
export class ErrorService {
  private errorSubject = new Subject<ErrorEvent>();
  errors$ = this.errorSubject.asObservable();

  constructor() {}

  /**
   * Add an error message
   */
  addError(message: string, title = 'Error'): void {
    this.errorSubject.next({
      message,
      title,
      type: 'error',
      autoClose: true,
      duration: 5000
    });
  }

  /**
   * Add a warning message
   */
  addWarning(message: string, title = 'Warning'): void {
    this.errorSubject.next({
      message,
      title,
      type: 'warning',
      autoClose: true,
      duration: 5000
    });
  }

  /**
   * Add an info message
   */
  addInfo(message: string, title = 'Info'): void {
    this.errorSubject.next({
      message,
      title,
      type: 'info',
      autoClose: true,
      duration: 5000
    });
  }

  /**
   * Add a success message
   */
  addSuccess(message: string, title = 'Success'): void {
    this.errorSubject.next({
      message,
      title,
      type: 'success',
      autoClose: true,
      duration: 5000
    });
  }

  /**
   * Clear all errors
   */
  clearErrors(): void {
    this.errorSubject.next({
      message: '',
      type: 'info',
      autoClose: false
    });
  }
}
```

## 3. Loading Service (src/app/services/loading.service.ts)

```typescript
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class LoadingService {
  private loadingSubject = new BehaviorSubject<boolean>(false);
  private loadingMap = new Map<string, boolean>();

  constructor() {}

  /**
   * Get loading state as observable
   */
  getLoading(): Observable<boolean> {
    return this.loadingSubject.asObservable();
  }

  /**
   * Set loading state for a specific operation
   */
  setLoading(loading: boolean, url: string): void {
    if (loading) {
      this.loadingMap.set(url, loading);
      this.loadingSubject.next(true);
    } else if (!loading && this.loadingMap.has(url)) {
      this.loadingMap.delete(url);
      this.loadingSubject.next(this.loadingMap.size > 0);
    }
  }
}
```

## 4. HTTP Interceptor (src/app/services/http-interceptor.service.ts)

```typescript
import { Injectable } from '@angular/core';
import {
  HttpEvent,
  HttpHandler,
  HttpInterceptor,
  HttpRequest,
  HttpErrorResponse
} from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError, finalize } from 'rxjs/operators';
import { ErrorService } from './error.service';
import { LoadingService } from './loading.service';

@Injectable()
export class HttpInterceptorService implements HttpInterceptor {

  constructor(
    private errorService: ErrorService,
    private loadingService: LoadingService
  ) {}

  intercept(
    request: HttpRequest<any>,
    next: HttpHandler
  ): Observable<HttpEvent<any>> {
    
    // Set loading state to true
    this.loadingService.setLoading(true, request.url);

    return next.handle(request).pipe(
      catchError((error: HttpErrorResponse) => {
        let errorMessage = '';
        
        if (error.error instanceof ErrorEvent) {
          // Client-side error
          errorMessage = `Error: ${error.error.message}`;
        } else {
          // Server-side error
          errorMessage = error.error?.message || 
                          `Error Code: ${error.status}, Message: ${error.message}`;
        }
        
        this.errorService.addError(errorMessage);
        return throwError(() => new Error(errorMessage));
      }),
      finalize(() => {
        // Set loading state to false
        this.loadingService.setLoading(false, request.url);
      })
    );
  }
}
```

## 5. App Module (src/app/app.module.ts)

```typescript
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { RouterModule, Routes } from '@angular/router';

import { AppComponent } from './app.component';
import { TaskListComponent } from './components/task-list/task-list.component';
import { TaskFormComponent } from './components/task-form/task-form.component';
import { TaskItemComponent } from './components/task-item/task-item.component';
import { AlertComponent } from './components/alert/alert.component';
import { LoadingComponent } from './components/loading/loading.component';
import { HeaderComponent } from './components/header/header.component';
import { FooterComponent } from './components/footer/footer.component';
import { PageNotFoundComponent } from './components/page-not-found/page-not-found.component';

import { HttpInterceptorService } from './services/http-interceptor.service';

const routes: Routes = [
  { path: '', redirectTo: '/tasks', pathMatch: 'full' },
  { path: 'tasks', component: TaskListComponent },
  { path: 'tasks/new', component: TaskFormComponent },
  { path: 'tasks/:id', component: TaskFormComponent },
  { path: '**', component: PageNotFoundComponent }
];

@NgModule({
  declarations: [
    AppComponent,
    TaskListComponent,
    TaskFormComponent,
    TaskItemComponent,
    AlertComponent,
    LoadingComponent,
    HeaderComponent,
    FooterComponent,
    PageNotFoundComponent
  ],
  imports: [
    BrowserModule,
    HttpClientModule,
    FormsModule,
    ReactiveFormsModule,
    RouterModule.forRoot(routes)
  ],
  providers: [
    {
      provide: HTTP_INTERCEPTORS,
      useClass: HttpInterceptorService,
      multi: true
    }
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

## 6. App Component (src/app/app.component.ts)

```typescript
import { Component } from '@angular/core';
import { LoadingService } from './services/loading.service';
import { ErrorService, ErrorEvent } from './services/error.service';
import { Observable } from 'rxjs';

@Component({
  selector: 'app-root',
  template: `
    <div class="slds-scope">
      <app-header></app-header>
      
      <div class="slds-container_center slds-container_x-large">
        <app-alert *ngIf="error$ | async as error" 
          [message]="error.message"
          [title]="error.title"
          [type]="error.type">
        </app-alert>
        
        <app-loading *ngIf="loading$ | async"></app-loading>
        
        <div class="slds-m-around_medium">
          <router-outlet></router-outlet>
        </div>
      </div>
      
      <app-footer></app-footer>
    </div>
  `,
  styles: []
})
export class AppComponent {
  loading$: Observable<boolean>;
  error$: Observable<ErrorEvent>;

  constructor(
    private loadingService: LoadingService,
    private errorService: ErrorService
  ) {
    this.loading$ = this.loadingService.getLoading();
    this.error$ = this.errorService.errors$;
  }
}
```