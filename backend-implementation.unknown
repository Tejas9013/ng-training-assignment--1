# Backend Implementation Files

## 1. Task Model (models/taskModel.js)

```javascript
const mongoose = require('mongoose');

const taskSchema = new mongoose.Schema({
  title: {
    type: String,
    required: [true, 'Task title is required'],
    trim: true,
    maxlength: [100, 'Title cannot be more than 100 characters']
  },
  description: {
    type: String,
    trim: true,
    maxlength: [500, 'Description cannot be more than 500 characters']
  },
  status: {
    type: String,
    enum: ['pending', 'completed'],
    default: 'pending'
  },
  priority: {
    type: String,
    enum: ['low', 'normal', 'high'],
    default: 'normal'
  },
  dueDate: {
    type: Date,
    validate: {
      validator: function(value) {
        return !value || value >= new Date();
      },
      message: 'Due date cannot be in the past'
    }
  },
  assignedTo: {
    type: String,
    trim: true,
    maxlength: [50, 'Assigned user name cannot be more than 50 characters']
  },
  comments: {
    type: String,
    trim: true,
    maxlength: [1000, 'Comments cannot be more than 1000 characters']
  }
}, {
  timestamps: true,
  versionKey: false
});

// Indexes for performance optimization
taskSchema.index({ status: 1 });
taskSchema.index({ priority: 1 });
taskSchema.index({ dueDate: 1 });
taskSchema.index({ createdAt: -1 });

// Virtual for task age in days
taskSchema.virtual('ageInDays').get(function() {
  return Math.floor((Date.now() - this.createdAt) / (1000 * 60 * 60 * 24));
});

// Transform output to include virtuals
taskSchema.set('toJSON', { virtuals: true });
taskSchema.set('toObject', { virtuals: true });

module.exports = mongoose.model('Task', taskSchema);
```

## 2. Task Controller (controllers/taskController.js)

```javascript
const Task = require('../models/taskModel');
const { validationResult } = require('express-validator');

class TaskController {
  // GET /api/tasks - Retrieve all tasks with pagination and filtering
  static async getAllTasks(req, res) {
    try {
      const page = parseInt(req.query.page) || 1;
      const limit = parseInt(req.query.limit) || 10;
      const skip = (page - 1) * limit;
      
      // Build filter object
      const filter = {};
      if (req.query.status) {
        filter.status = req.query.status;
      }
      if (req.query.priority) {
        filter.priority = req.query.priority;
      }
      if (req.query.search) {
        filter.$or = [
          { title: { $regex: req.query.search, $options: 'i' } },
          { description: { $regex: req.query.search, $options: 'i' } }
        ];
      }

      // Build sort object
      const sort = {};
      if (req.query.sortBy) {
        const parts = req.query.sortBy.split(':');
        sort[parts[0]] = parts[1] === 'desc' ? -1 : 1;
      } else {
        sort.createdAt = -1; // Default sort by newest first
      }

      const tasks = await Task.find(filter)
        .sort(sort)
        .limit(limit)
        .skip(skip);

      const totalTasks = await Task.countDocuments(filter);
      const totalPages = Math.ceil(totalTasks / limit);

      res.status(200).json({
        success: true,
        data: {
          tasks,
          pagination: {
            currentPage: page,
            totalPages,
            totalTasks,
            hasNextPage: page < totalPages,
            hasPrevPage: page > 1
          }
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'Error fetching tasks',
        error: error.message
      });
    }
  }

  // GET /api/tasks/:id - Get task by ID
  static async getTaskById(req, res) {
    try {
      const task = await Task.findById(req.params.id);
      
      if (!task) {
        return res.status(404).json({
          success: false,
          message: 'Task not found'
        });
      }

      res.status(200).json({
        success: true,
        data: task
      });
    } catch (error) {
      if (error.name === 'CastError') {
        return res.status(400).json({
          success: false,
          message: 'Invalid task ID format'
        });
      }
      
      res.status(500).json({
        success: false,
        message: 'Error fetching task',
        error: error.message
      });
    }
  }

  // POST /api/task - Create new task
  static async createTask(req, res) {
    try {
      // Check for validation errors
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'Validation failed',
          errors: errors.array()
        });
      }

      const task = new Task(req.body);
      const savedTask = await task.save();

      res.status(201).json({
        success: true,
        message: 'Task created successfully',
        data: savedTask
      });
    } catch (error) {
      if (error.name === 'ValidationError') {
        return res.status(400).json({
          success: false,
          message: 'Validation failed',
          errors: Object.values(error.errors).map(err => ({
            field: err.path,
            message: err.message
          }))
        });
      }

      res.status(500).json({
        success: false,
        message: 'Error creating task',
        error: error.message
      });
    }
  }

  // PUT /api/task/:id - Update task by ID
  static async updateTask(req, res) {
    try {
      // Check for validation errors
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: 'Validation failed',
          errors: errors.array()
        });
      }

      const task = await Task.findByIdAndUpdate(
        req.params.id,
        req.body,
        { 
          new: true, 
          runValidators: true 
        }
      );

      if (!task) {
        return res.status(404).json({
          success: false,
          message: 'Task not found'
        });
      }

      res.status(200).json({
        success: true,
        message: 'Task updated successfully',
        data: task
      });
    } catch (error) {
      if (error.name === 'CastError') {
        return res.status(400).json({
          success: false,
          message: 'Invalid task ID format'
        });
      }

      if (error.name === 'ValidationError') {
        return res.status(400).json({
          success: false,
          message: 'Validation failed',
          errors: Object.values(error.errors).map(err => ({
            field: err.path,
            message: err.message
          }))
        });
      }

      res.status(500).json({
        success: false,
        message: 'Error updating task',
        error: error.message
      });
    }
  }

  // DELETE /api/task/:id - Delete task by ID
  static async deleteTask(req, res) {
    try {
      const task = await Task.findByIdAndDelete(req.params.id);

      if (!task) {
        return res.status(404).json({
          success: false,
          message: 'Task not found'
        });
      }

      res.status(200).json({
        success: true,
        message: 'Task deleted successfully',
        data: task
      });
    } catch (error) {
      if (error.name === 'CastError') {
        return res.status(400).json({
          success: false,
          message: 'Invalid task ID format'
        });
      }

      res.status(500).json({
        success: false,
        message: 'Error deleting task',
        error: error.message
      });
    }
  }

  // GET /api/tasks/stats - Get task statistics
  static async getTaskStats(req, res) {
    try {
      const stats = await Task.aggregate([
        {
          $group: {
            _id: '$status',
            count: { $sum: 1 }
          }
        }
      ]);

      const priorityStats = await Task.aggregate([
        {
          $group: {
            _id: '$priority',
            count: { $sum: 1 }
          }
        }
      ]);

      const totalTasks = await Task.countDocuments();

      res.status(200).json({
        success: true,
        data: {
          totalTasks,
          statusBreakdown: stats,
          priorityBreakdown: priorityStats
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: 'Error fetching task statistics',
        error: error.message
      });
    }
  }
}

module.exports = TaskController;
```

## 3. Task Routes (routes/taskRoutes.js)

```javascript
const express = require('express');
const TaskController = require('../controllers/taskController');
const { taskValidationRules } = require('../middleware/validation');

const router = express.Router();

// GET /api/tasks - Retrieve all tasks
router.get('/tasks', TaskController.getAllTasks);

// GET /api/tasks/stats - Get task statistics
router.get('/tasks/stats', TaskController.getTaskStats);

// GET /api/tasks/:id - Get task by ID
router.get('/tasks/:id', TaskController.getTaskById);

// POST /api/task - Create new task
router.post('/task', taskValidationRules(), TaskController.createTask);

// PUT /api/task/:id - Update task by ID
router.put('/task/:id', taskValidationRules(), TaskController.updateTask);

// DELETE /api/task/:id - Delete task by ID
router.delete('/task/:id', TaskController.deleteTask);

module.exports = router;
```

## 4. Validation Middleware (middleware/validation.js)

```javascript
const { body } = require('express-validator');

const taskValidationRules = () => {
  return [
    body('title')
      .trim()
      .notEmpty()
      .withMessage('Task title is required')
      .isLength({ max: 100 })
      .withMessage('Title cannot be more than 100 characters'),
    
    body('description')
      .optional()
      .trim()
      .isLength({ max: 500 })
      .withMessage('Description cannot be more than 500 characters'),
    
    body('status')
      .optional()
      .isIn(['pending', 'completed'])
      .withMessage('Status must be either pending or completed'),
    
    body('priority')
      .optional()
      .isIn(['low', 'normal', 'high'])
      .withMessage('Priority must be low, normal, or high'),
    
    body('dueDate')
      .optional()
      .isISO8601()
      .withMessage('Due date must be a valid date')
      .custom((value) => {
        if (value && new Date(value) < new Date()) {
          throw new Error('Due date cannot be in the past');
        }
        return true;
      }),
    
    body('assignedTo')
      .optional()
      .trim()
      .isLength({ max: 50 })
      .withMessage('Assigned user name cannot be more than 50 characters'),
    
    body('comments')
      .optional()
      .trim()
      .isLength({ max: 1000 })
      .withMessage('Comments cannot be more than 1000 characters')
  ];
};

module.exports = {
  taskValidationRules
};
```